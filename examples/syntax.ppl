-------- Syntax guide --------

-- This is a single line comment.

{-
This is a multi-line comment.
It can appear just about anywhere,
even in the middle of a line of code.
-}

-- You can define datatypes like this:

data String = Nil | Cons Bool String;

data State = q0 | q1 | q2;

-- Unfortunately we need to state types at def and also in lambdas
define not : Bool -> Bool =
  \ b. if b then False else True;

define and = -- optional `: type` annotations
  \ a. \ b. if a then b else False;

define iff : Bool -> Bool -> Bool =
  \ a. \ b. if a then b else not b;


define string_eq = \ w1. \ w2 : String. -- optional `: type` annotations on lambdas
  case w1 of
    | Nil -> (case w2 of Nil -> True | Cons a w' -> False)
    | Cons b1 w1' -> (case w2 of Nil -> True | Cons b2 w2' -> and (iff b1 b2) (string_eq w1' w2'));

  -- Note the closing semicolon ^

-- You can declare external distributions like this:
extern transition : State -> Bool * State;
extern accept : State -> Bool;

define gen : State -> String =
  \ q. if accept q then Nil else (let (a, r) = transition q in Cons a (gen r));

define products =
  \ prod : Bool * State. \ amp : Bool & State.
    -- With *-types, you can access both parts like this:
    let (b, q) = prod in
    -- But with &-types, you can only access ONE part:
    let <b', _> = amp in
    -- or: let <_, q'> = amp in ...
    -- You CANNOT do
    -- let <b', q'> = amp in ...
    -- Nor can you use use amp twice
    
    -- To make a *-product:
    let prod' = (False, q1) in
    -- To make a &-product:
    let amp' = <False, q1> in
    True;


define samples : (Bool -> Bool -> Bool) -> Bool =
  \ f. f
    (fail)                    -- p(False) = 0,   p(True) = 0   (all members get p = 0)
    (amb False True False);   -- p(False) = 2,   p(True) = 1   (all branches get p = 1)

-- You can also define polymorphic functions:
define compose =
  \ f. \ g. \ x. f (g x);

--define use_compose1 =
--  compose not accept;
--define use_compose2 =
--  compose (string_eq Nil) gen;
define use_compose3 =
  compose compose; --compos compose (compose (compose compose (compose compose) compose));

--define id = \ x. x;

--define testId = id False;

-- You must then end the program with something to run, like
--let foo = use_compose1 in let bar = use_compose2 in use_compose3;
string_eq (gen q0) (gen q0)
