-- Requires tag polymorphism.

data Nat = Zero | Succ Nat;
data List a = Nil | Cons a (List a);

define even : Nat -> Bool = \ n.
  case n of
  | Zero -> True
  | Succ n' -> not (even n');

define not = \ a. if a then False else True;
define xor = \ a. \ b. if a then not b else b;
define XOR = \ l. case l of Nil -> False | Cons h t -> xor h (XOR t);


define exp0 = Succ Zero;
define exp1 = double exp0;
define exp2 = double exp1;
define exp3 = double exp2;
define exp4 = double exp3;
define exp5 = double exp4;
define exp6 = double exp5;
define exp7 = double exp6;
define exp8 = double exp7;
define exp9 = double exp8;
define exp10 = double exp9;
define exp11 = double exp10;
define exp12 = double exp11;
define exp13 = double exp12;
define exp14 = double exp13;
define exp15 = double exp14;
define exp16 = double exp15;
define exp17 = double exp16;
define exp18 = double exp17;
define exp19 = double exp18;
define exp20 = double exp19;
define exp21 = double exp20;
define exp22 = double exp21;
define exp23 = double exp22;
define exp24 = double exp23;
define exp25 = double exp24;

define rev0 = Cons True (Cons False Nil);
define rev1 = reverse rev0;
define rev2 = reverse rev1;
define rev3 = reverse rev2;
define rev4 = reverse rev3;
define rev5 = reverse rev4;
define rev6 = reverse rev5;
define rev7 = reverse rev6;
define rev8 = reverse rev7;



-- Head-recursive
define doubleH = \n: Nat.
  case n of
  | Zero -> Zero
  | Succ m -> Succ (Succ (doubleH m));

-- Tail-recursive
define doubleT' : Nat -> Nat -> Nat = \ acc. \ n.
  case n of
  | Zero -> acc
  | Succ n' -> doubleT' (Succ (Succ acc)) n';

define doubleT = doubleT' Zero;

-- Head-recursive fails to D/R
--define snoc = \ xs. \ y. case xs of
--  | Nil -> Cons y Nil
--  | Cons x xs -> Cons x (snoc xs y);
--define reverseH = \ xs. case xs of
--  | Nil -> Nil
--  | Cons x xs -> snoc (reverse xs) x;

-- Tail-recursive
-- reverseT' : Forall a. List a -> List a -> List a
define reverseT' = \ acc. \ xs. case xs of
  | Nil -> acc
  | Cons x xs' -> reverseT' (Cons x acc) xs';
define reverseT = reverseT' Nil;

-- reverse : Forall a. List a -> List a
define reverse = reverseT;
define double = doubleH;

-- Note that nested tail-recursive calls (e.g. double, reverse)
-- cause double-exponential increase in factor size of their
-- refunctionalized datatypes

XOR rev1;
--even exp1;



{-define natEq = \m: Nat. \n: Nat.
  case m of
      Zero -> (case n of Zero -> True | Succ _ -> False)
    | Succ m -> (case n of Zero -> False | Succ n -> natEq m n);-}

-- listEq : Forall a. List a -> List a -> Bool
{-define listEq = \ xs. \ ys. case xs of
  | Nil -> (case ys of Nil -> True | Cons y ys' -> False)
  | Cons x xs' -> (case ys of Nil -> False | Cons y ys' -> if x == y then listEq xs' ys' else False);-}